# Design Decisions

This document lists the reasoning behind some of the design decisions made in `@brandonkal/linaria`.

## User facing

#### Prop filtering

Props that end in "\$" are not forwarded to the DOM. This convention greatly simplifies the prop forwarding logic and makes it clear just from looking at the source code if a prop will make it into the DOM as an HTML attribute. Using a suffix over a prefix was chosen for quicker auto-complete suggestions.

This has the added benefit of a much smaller styled runtime as there is no dependency on `@emotion/is-prop-valid`.

#### Modifiers

This allows all style logic to be contained inside your CSS. Using an array literal inside the interpolation was chosen as a simple way to recognize if an interpolation should be parsed as a modifier condition or a value to evaluate. It also looks quite similar to CSS attribute selectors which is an added benefit.

Modifier classnames are automatically generated in development by reading the source code in the array literal. This means that you can think more in terms of what conditions will cause a block of styles to be applied rather than what that block of styles will be labeled as.

#### Tiny Class Names

Tiny class names are generated by wrapping generated class name identifiers like so: `LINARIA_cls_LINARIA`.

A Webpack plugin then replaces these strings with regular expressions. This generally allows shorter class names as unused classes will be excluded from the bundle by the time this replacement process occurs. The plugin keeps a mapping of original class name to shortened replacement class name.

While it is true that gzip can negate much of the benefit of using shorter class names, it is also true that the generated class names hashes do not compress as well as english text. The automatic BEM-like modifier class names, can be quite long. While these are immensely useful in development, they also pollute the HTML. Because these names are entirely controlled by linaria, it is possible to generate the shortest possible class names to use in production. With source maps, readability remains high.

#### PostCSS

The original linaria used `stylis` for processing styles. Meanwhile, `postCSS` is standard for processing CSS files in the build pipeline. The main benefit of `stylis` is its smaller size. However, because all CSS processing is done during build and the processor is not shipped to the browser, this benefit does not exist for linaria. Using `postCSS` also opens up the door to many more possibilities for using existing postCSS plugins. This fork removed the extra complexity so that only one CSS processor is used in the CSS pipeline. This also helps improve build time performance.

#### The wrapping shortcut

From using tools like Styled Components, the one annoyance I had in authoring stylesheets inside Javascript was the constant need to type out arrow functions. When TypeScript is added into the mix, adding typings for all those functions becomes even more tedious. With the wrapping shortcut, this is no longer necessary. This also improves readability for stylesheets.

#### Removal of Linaria Stylelint processor

Stylelint now has native support for CSS-in-JS. This enables doing things such as auto-fix which is not possible with a processor. The processor was removed in favor of preferring the native CSS-in-JS support.

#### Default Cache Location

The default cache location was moved to `node_modules/cache/@brandonkal/linaria` to be more consistant with other tools.

#### Component.cls

WARNING: This is considered experimental. Consider it undocumented. Until this behaviour is added to the Type Definitions, removal of this behaviour will not be considered a breaking change!

After evaluating normally, if this property exists on an interpolation value, it will be used in the generated CSS. This is handy for making any function behave as if it was a linaria css class Name.

In my own component library, I found myself reaching for `styledComponent.__linaria.className` and attaching that to components that render a styled component. That approach isn't very clean.

The idea is that eventually something like this should be possible:

```jsx
const Base = styled.div``;
function Checkbox() {
  return <Base>{checked ? 'Checked' : ''}</Base>;
}
Checkbox.cls = Base.cls;
export default Checkbox;
// Another file
import Checkbox from 'checkbox';
const Options = styled.div`
  .${Checkbox} {
    color: blue;
  }
`;
```

#### throwIfInvalid

Empty objects in interpolated values are now considered errors as this is most likely a mistake. Empty strings will not throw as this has a valid use case.

## Internal Code

#### Removal of the shaker

The shaker is a really slick piece of code. Before forking this project the shaker did two things:

1. Built a dependency tree and shook the code to remove unused nodes.
2. Added linaria-specific exports.

Before removing the shaker from the plugin code path, I split those into two. It is my opinion that the first part could be made into a very useful standalone babel transform. However, the shaker logic is very complex and because of some code changes, is no longer necessary for preval support.

Before removing the shaker, it had some issues with keeping dependencies of arrays and removing uninitialized variable declarations:

`let thing; export const a = thing; >> export const a = thing`

##### Why it is no longer required:

In order to improve caching performance and reduce build time, I have changed linaria to export items that need to be pre-evaluated on a new key rather than only exporting those items. Because babel works on a single file at a time, it cannot know which exports will be required by other files to evaluate their expressions. This resulted in linaria processing and transforming files several times to evaluate different exports. By exporting the values on a seperate key, the transformed code can be cached and persisted to disk between project builds. It only needs to change when the source file changes.

#### \_\_linariaPreval

As explained above, this added export improves build time performance by reducing the number of transforms required to just one per source file. It is inserted as an ES6 export so that the commonjs transformer will include the name in its generated `_exportedNames` object. This is required to avoid evaluation errors.

The lazyDeps array is pushed into the program before evaluation and removed after evaluation.

The export must exist regardless of if the file uses linaria:

```js
export * from 'linariaComponent1';
export * from 'linariaComponent2';
export const __linariaPreval = [];
```

Without that last export, which the transformer appends to the file, the above code would result in a syntax error due to re-defining a \_\_linariaPreval export which is exported from both files.

When converted to commonJS for evaluation, `export *` will ignore exports that are already exported by the current file.

#### VM Global

Errors are passed through so that instances will work for Error. Sometimes this doesn't work. `module.evaluate` has a trap that will convert error-like-objects to actual Errors so that these checks will work in Webpack and other bundler code.

The entire global object is not passed through in order to isolate it from code that runs in the VM. This means code cannot call for instance `global.Set()` to access normal Javascript built-ins. I have yet to see a module that actually does this though and a normal call to `Set()` will work. Functions that are added by the Node runtime such as setTimeout are available in the vm global object.

#### VM context

A single vm context is used for evaluation. Instead, vm.compileFunction is used. This is closer to how commonJS works natively and should improve evaluation performance. This approach also fixes edge cases present in the original Linaria such as instanceof not working across module boundaries in the VM.

#### Preval transform Babel Options

When transforming code for preval, the user Babel config is used with the required plugins added. If the user uses `@babel/preset-env`, the target is overriden to `{ node: 'current' }`. This ensures that unnessary transforms are not performed (such as ES6 to ES5) and most polyfills are not added. Note this is only for preval and has no effect on the final generated code.

#### Module.\_prepareStack

This function ensures an actual error is returned when thrown. It also generates a nice code frame. Because the stack is already created and formatted at this time, regular expressions are required to parse the generated stack and deduce a code frame position. This produces beautiful stack traces consistant with those created by `ex.buildCodeFrameError`. Should this process fail, the original error is thrown.

#### buildCSS

This logic handles building a CSS-like-string from the extracted rules. This is only required when not evaluating. A replace map is used so that all Javascript transformations (outside of the removal of the \_\_linariaPreval exports) occur before the code is evaluated. Again, this is to improve caching of work.

The call to this function was moved into the babel plugin process as the intent is to eventually remove the requirement for a special webpack loader or cli.

In the future, it should be possible to avoid writing the intermediate CSS file to disk by writing a generic buffer-loader for all of the bundlers that will handle a base-encoded require string and process it as if it was a file on disk.

#### Limitations

Certain limitations exist to ensure performant development.

Preval Evaluation: If `options.evaluate == true`, any identifiers as a CSS expression will be evaluated to determine if it is a runtime function or a value (i.e. string). During development, Linaria rebuild CSS without rebuilding the Javascript for performance.
For instance:

```js
// A.js
export const fontSize = 16;
export const A = css`
  color: blue;
`;
```

```js
// Tag.js
import { fontSize } from './A';
const Tag = styled.span`
  font-size: ${fontSize}px;
`;
```

Changing A.js will cause `linaria-loader` to rebuild `A.js`, `A.js.linaria.css`, and `Tag.js.linaria.css`
Note that `Tag.js` does not need to be rebuilt in this case.
This works great as long as you don't change `fontSize` from a primitive into a function. If you do this, simply change Tag.js (i.e. with a cahe-busting comment) to force webpack to rebuild the dependent file and output updated JavaScript.
